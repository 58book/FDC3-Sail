/**
 * connect from HTML content to main process
 */

import utils from '../../../main/src/utils';
import { FDC3Event } from '../../../main/src/types/FDC3Event';
import { FDC3Message } from '../../../main/src/types/FDC3Message';
import { Context } from '@finos/fdc3';
import { ipcRenderer } from 'electron';
import { TOPICS } from '../../../main/src/constants';

//const {port1, port2} = new MessageChannel();

//flag to indicate the background script is ready for fdc3!
let connected = false;
let id = '';

//queue of pending events - accumulate until the background is ready
const eventQ: Array<FDC3Message> = [];

/**
 * listen for start event - assigning id for the instance
 */

ipcRenderer.on(TOPICS.FDC3_START, async (event, args) => {
  console.log('fdc3 start', args);
  if (args.id) {
    id = args.id;
    //handle directory metadata
    if (args.directory) {
      directoryData = args.directory;
      //is there actions meta data defined? If so, wire up listeners if intents and context metadata are there
      const actions = args.directory.actions || null;

      //set globals (?)
      contentName = args.directory ? args.directory.name : null;
      contentActions = actions;
      //if there is action metadata for the app in the directory - set up intent & context handlers
      if (actions) {
        //generate a guid for the listener
        //this would normally come from the api layer in the dom...
        const guid = utils.guid();
        console.log('actions', actions);
        if (actions.intents) {
          //iterate through the intents, and set listeners
          actions.intents.forEach((intent: any) => {
            const msg = {
              topic: 'addIntentListener',
              source: id,
              data: { id: guid, intent: intent.intent },
            };
            sendMessage(msg);
            // ipcRenderer.send("FDC3:addIntentListener", {"data": {id: guid, intent:intent.intent }});
            _intentHandlers.push(intent.intent);
          });
        }
        if (actions.contexts) {
          //iterate through context metadata and set listeners

          actions.contexts.forEach((context: Context) => {
            const msg = {
              topic: 'addContextListener',
              source: id,
              data: { id: guid, context: context.type },
            };
            sendMessage(msg);
            //ipcRenderer.send("FDC3:addContextListener",{"data": {id: guid, context:context.type}});
            _contextHandlers.push(context.type);
          });
        }
      }
    }
    connected = true;
    //send any queued messages
    eventQ.forEach((msg) => {
      msg.source = id;
      //ipcRenderer.postMessage(`FDC3:${msg.topic}`, msg, [port2]);
      sendMessage(msg);
    });

    document.dispatchEvent(new CustomEvent('fdc3Ready', {}));
  }
});

/**
 * return listeners
 * most fdc3 api calls are promise based and many require resolution/rejection following complex interaction that may involve end user input, app loading times etc
 * so, we need to a symetrical return event when events are dispatched to the background script and to uniquely identifiy the event
 * also, need to support timeout/expiration of the event, for example, if an app takes too long to load or an end user never responds to a prompt
 *
 * all promise based FDC3 methods send an event to the background script and listens for an event of "return" + eventName
 * a unique identifier is assigned to the event (timestamp)
 * the return handler will route back to correct handler function via the timestamp identifier
 * handlers will be routinely cleaned up by finding all events that have expired (check timestamp) and rejecting those items
 */
//collection of listeners for api calls coming back from the background script
const returnListeners: Map<string, any> = new Map();
//const returnTimeout = 1000 * 60 * 2;

//automated handlers based on manifest metadata - other handlers are set and dispatched by the API layer
//these just need to be markers - since the handling itself is just autogenerated from the metadata held in the manifest
const _intentHandlers: Array<string> = [];
const _contextHandlers: Array<string> = [];
let contentActions: any = null;
let contentName: string | null = null;
//let currentChannel: string | null = null;
let directoryData: any = null;

const sendMessage = (msg: FDC3Message) => {
  const { port1, port2 } = new MessageChannel();

  port1.onmessage = (event: MessageEvent) => {
    const msg = event.data;
    //is there a returnlistener registered for the event?
    const listener = returnListeners.has(msg.topic)
      ? returnListeners.get(msg.topic).listener
      : null;
    if (listener) {
      listener.call(window, msg);
      returnListeners.delete(msg.name);
    }
  };

  ipcRenderer.postMessage(`FDC3:${msg.topic}`, msg, [port2]);
};

const wireTopic = (topic: string, config?: any): void => {
  (document as any).addEventListener(`FDC3:${topic}`, (e: FDC3Event) => {
    console.log('contentConnect event', e);
    const cb = config ? config.cb : null;
    const isVoid = config ? config.isVoid : null;

    //get eventId and timestamp from the event
    if (!isVoid) {
      const eventId: string | null | undefined =
        e.detail !== null ? e.detail.eventId : null;

      if (eventId) {
        returnListeners.set(eventId, {
          ts: e.ts,
          listener: function (msg: FDC3Message) {
            document.dispatchEvent(
              utils.fdc3Event(`return_${eventId}`, msg.data),
            );
          },
        });
      }
      if (cb) {
        cb.call(document, e);
      }
    }
    //if  background script isn't ready yet, queue these messages...
    const msg: FDC3Message = { topic: topic, source: id, data: e.detail };
    console.log(`FDC3:${topic} - connected state`, connected);
    if (!connected) {
      eventQ.push(msg);
    } else {
      sendMessage(msg);
    }
  });
};

//listen for FDC3 events
export const listen = () => {
  const topics = [
    'open',
    'raiseIntent',
    'addContextListener',
    'addIntentListener',
    'findIntent',
    'findIntentsByContext',
    'getCurrentContext',
    'getSystemChannels',
    'getOrCreateChannel',
    'getCurrentChannel',
    'getAppInstance',
  ];
  topics.forEach((t) => {
    wireTopic(t);
  });
  //set the custom ones...
  wireTopic('joinChannel', {
    cb: () => {
      //  currentChannel = e.detail && e.detail.channel ? e.detail.channel : null;
    },
  });
  wireTopic('leaveCurrentChannel', {
    cb: () => {
      //  currentChannel = 'default';
    },
  });
  wireTopic('broadcast', { isVoid: true });
  wireTopic('dropContextListener', { isVoid: true });
  wireTopic('dropIntentListener', { isVoid: true });
};

(document as any).addEventListener(
  TOPICS.CONTEXT_MENU,
  (event: CustomEvent) => {
    ipcRenderer.send(TOPICS.CONTEXT_MENU, { detail: event.detail, source: id });
  },
);

(document as any).addEventListener(TOPICS.SAVE_ENTITY, (event: CustomEvent) => {
  ipcRenderer.send(TOPICS.SAVE_ENTITY, { detail: event.detail, source: id });
});

const actionUrl = (data: any): Promise<string> => {
  return new Promise((resolve, reject) => {
    try {
      //const body: any = { context: data.context };
      const eventId = `getActionUrl_${utils.guid()}`;
      data.appName = contentName;
      //push this to main process
      ipcRenderer.once(`FDC3:${eventId}`, (event, args) => {
        resolve(args.data);
      });
      ipcRenderer.send(TOPICS.FDC3_GET_ACTION_URL, {
        source: id,
        eventId: eventId,
        data: data,
      });
    } catch (err) {
      reject(err);
    }
  });
};

export const connect = () => {
  /**
   * listen for incomming contexts
   */
  ipcRenderer.on(TOPICS.FDC3_CONTEXT, async (event, args) => {
    console.log('ipcrenderer event', event);
    //check for handlers at the content script layer (automatic handlers) - if not, dispatch to the API layer...
    let contextSent = false;
    if (args.data && args.data.context) {
      if (
        _contextHandlers.indexOf(args.data.context.type) > -1 &&
        directoryData.hasActions
      ) {
        const ctxUrl = await actionUrl(args.data);
        //don't reload if they are the same...
        //don't redirect if url is empty (i.e. nothing found for the action)
        if (ctxUrl && window.location.href !== ctxUrl) {
          window.location.href = ctxUrl;
          document.dispatchEvent(
            new CustomEvent(TOPICS.NAVIGATE, {
              detail: { href: ctxUrl },
            }),
          );
          contextSent = true;
        }
        //focus the actual tab
        //window.focus();
      }
      if (!contextSent) {
        document.dispatchEvent(
          new CustomEvent(TOPICS.FDC3_CONTEXT, {
            detail: { data: args.data, source: args.source },
          }),
        );
      }
    }
  });

  /**
   * listen for incoming intents
   */
  ipcRenderer.on(TOPICS.FDC3_INTENT, async (event, args) => {
    console.log('ipcrenderer event', event);
    let intentSent = false;
    //check for handlers at the content script layer (automatic handlers) - if not, dispatch to the API layer...
    if (_intentHandlers.indexOf(args.data.intent) > -1 && contentActions) {
      const intUrl: string = await actionUrl(args.data);

      //don't reload if they are the same...
      if (intUrl && window.location.href !== intUrl) {
        window.location.href = intUrl;
        intentSent = true;
      }
      // window.focus();
    }
    if (!intentSent) {
      document.dispatchEvent(
        new CustomEvent(TOPICS.FDC3_INTENT, {
          detail: { data: args.data, source: args.source },
        }),
      );
    }
  });

  /**
   * listen for channel state update
   * to do: do we need this?
   */
  ipcRenderer.on(TOPICS.FDC3_SET_CURRENT_CHANEL, (event, args) => {
    console.log('ipcrenderer event', event);
    if (args.data.channel) {
      //  currentChannel = args.data.channel;
    }
  });
};

//prevent timing issues from very first load of the preload
ipcRenderer.send('FDC3:initiate', {});
